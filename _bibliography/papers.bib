---
---

@misc{koutras2021valentine,
      title={Valentine: Evaluating Matching Techniques for Dataset Discovery},
      author={Christos Koutras and George Siachamis and Andra Ionescu and Kyriakos Psarakis and Jerry Brons and Marios Fragkoulis and Christoph Lofi and Angela Bonifati and Asterios Katsifodimos},
      year={2021},
      eprint={2010.07386},
      archivePrefix={arXiv},
      primaryClass={cs.DB},
      abbr = {ICDE 2021},
      pdf = {https://arxiv.org/pdf/2010.07386.pdf},
      arxiv = {arXiv:2010.07386},
      blog = {https://delftdata.github.io/valentine/},
}

@inproceedings{10.1145/3465480.3466920,
author = {Martijn {de Heus} and Kyriakos Psarakis and Marios Fragkoulis and Asterios Katsifodimos},
title = {<span style="color: #C70039">(üèÜ BPA)</span> Distributed Transactions on Serverless Stateful Functions},
year = {2021},
abbr = {DEBS 2021},
pdf = {https://dl-acm-org.tudelft.idm.oclc.org/doi/pdf/10.1145/3465480.3466920},
isbn = {9781450385558},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi-org.tudelft.idm.oclc.org/10.1145/3465480.3466920},
doi = {10.1145/3465480.3466920},
abstract = {Serverless computing is currently the fastest-growing cloud services segment. The
most prominent serverless offering is Function-as-a-Service (FaaS), where users write
functions and the cloud automates deployment, maintenance, and scalability. Although
FaaS is a good fit for executing stateless functions, it does not adequately support
stateful constructs like microservices and scalable, low-latency cloud applications,
mainly because it lacks proper state management support and the ability to perform
function-to-function calls. Most importantly, executing transactions across stateful
functions remains an open problem.In this paper, we introduce a programming model
and implementation for transaction orchestration of stateful serverless functions.
Our programming model supports serializable distributed transactions with two-phase
commit, as well as relaxed transactional guarantees with Sagas. We design and implement
our programming model on Apache Flink StateFun. We choose to build our solution on
top of StateFun in order to leverage Flink's exactly-once processing and state management
guarantees. We base our evaluation on the YCSB benchmark, which we extended with transactional
operations and adapted for the SFaaS programming model. Our experiments show that
our transactional orchestration adds 10% overhead to the original system and that
Sagas can achieve up to 34% more transactions per second than two-phase commit transactions
at a sub-200ms latency.},
booktitle = {Proceedings of the 15th ACM International Conference on Distributed and Event-Based Systems},
pages = {31‚Äì42},
numpages = {12},
keywords = {two-phase commit, serverless, transactions, sagas, streaming dataflow, FaaS},
location = {Virtual Event, Italy},
series = {DEBS '21}
}

@misc{koutrasvalentine,
abbr = {VLDB 2021},
year = {2021},
pdf = {http://vldb.org/pvldb/vol14/p2871-koutras.pdf},
journal={Proc. VLDB Endow. 2021 },
title={Valentine in Action: Matching Tabular Data at Scale},
author={Koutras, Christos and Psarakis, Kyriakos and Siachamis, George and Ionescu, Andra and Fragkoulis, Marios and Bonifati, Angela and Katsifodimos, Asterios}
}


@article{DEHEUS2022102015,
title = {Transactions across serverless functions leveraging stateful dataflows},
abbr = {Inf. Syst. J.},
year = {2022},
pdf = {https://pdf.sciencedirectassets.com/271528/AIP/1-s2.0-S0306437922000229/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEEYaCXVzLWVhc3QtMSJHMEUCIAWbkNORkTSngctLfQn8qwkO3lPA6kS9jEWsUXPCeA0dAiEAljRUBvgPGWfTmoo8%2FU2VijyxEXoaL99BjG75GyJPsT8qgwQIv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAEGgwwNTkwMDM1NDY4NjUiDFuKf%2BJmrmyQ79yg1irXA8xWDOk%2Fv2YctoarV3wgfzYNGJHo3B8L1qtB%2FJ%2BYavLN1OYtfAczevigzUy9JjwS8jDbs%2BMB2iOwebnqKg5eAYXpVylUZw7MTeAdfL8wvaTfsAF0fcuzRT5YXOU%2FnEsgnA7l%2FKeJS4IlQo8J7pdK%2BZ7cbVCJ%2FXGH1ho5ShqdkENxUEsO3pqyLV6Y2JbWp4XMDu7YDsA62Ua4Iqjx1ZIJ7gYRx6w2Z%2FL4bE0BTScUiec2KjTyKnZpBZBhMHmGtsiAvDna5fC01A%2B7IMpubXUgAG3z95W%2Bpk2DgY6NUCnnLIqWdKpWXAzaM1iLLrvu21daUgBu%2FNq4i1DOR1Gusqi49ufYUgmW%2F1Hw9bV%2F9tYWDBzfRFNk3baj9xZefCbLCfdvnWvheWyu8lkRqB5uJNeCIe5Lld8y6O5aVPZ8REMi2Y4GTIZrVguxtJoz1dmGeDWvNAzbbbZUdKQbLbVW8RyqaTIuFxmNDcSS47Be0%2BeC5XmyooyLkqocc%2FR1FJ5j52lbu8oP6O8a7a1F5Io7U%2BaYA8Z7JHlj872g8VmA6cfCmxtq6DWuXbiEGZvOcM%2F497M4ZMyihmC0tdcKnC9T91wjLHoC72PuNzKm%2BhZNdYAbHkUnvby5fok69zCFk9KRBjqlAX3zkUXmsWAWPlO9XF2gdCDX3IW%2FZHDiNZtmiQJRKVUT1kLRqgJUKpROcR%2BDhzFD4sVR%2B6YvOYchIjwaqGQIIuWTv9zaHb029CRnrpf%2FsHpXbg800bPxvpcOkM5z929fiAPX211C3y2%2FE1TPrwCXN4zYmF4EiLq0i7ZM0oc9zd0Vg%2FwtVAkSmA4zmBZQh0Oq4UZJNstee648tFbKC172HYqQ3mFLRA%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20220318T151556Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYX4LE3XXS%2F20220318%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=505d9361b0cad5d164657ab0843e2b112c31f3ca8aaeaabc4afc7816ff9b436a&hash=90b58a350b683a7449e64480d7b94913f8b359b4698f92bab86ef413e7f6b373&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0306437922000229&tid=spdf-55441965-042a-4b78-9e4b-c2b8d1d0377f&sid=297485445c91b147b028a8e82780637b11c7gxrqb&type=client&download=true&ua=4c030a000a0a5d58045f5b&rr=6edeed36f99f9740},
author = {Martijn {de Heus} and Kyriakos Psarakis and Marios Fragkoulis and Asterios Katsifodimos},
abstract = {Serverless computing is currently the fastest-growing cloud services segment. The most prominent serverless offering is Function-as-a-Service (FaaS), where users write functions and the cloud automates deployment, maintenance, and scalability. Although FaaS is a good fit for executing stateless functions, it does not adequately support stateful constructs like microservices and scalable, low-latency cloud applications. Recently, there have been multiple attempts to add first-class support for state in FaaS systems, such as Microsoft Orleans, Azure Durable Functions, or Beldi. These approaches execute business code inside stateless functions, handing over their state to an external database. In contrast, approaches such as Apache Flink‚Äôs StateFun follow a different design: a dataflow system such as Apache Flink handles all state management, messaging, and checkpointing by executing a stateful dataflow graph providing exactly-once state processing guarantees. This design relieves programmers from having to ‚Äúpollute‚Äù their business logic with distributed systems error checking, management, and mitigation. Although programmers can easily develop applications without worrying about messaging and state management, executing transactions across stateful functions remains an open problem. In this paper, we introduce a programming model and implementation for transaction orchestration of stateful serverless functions. Our programming model supports serializable distributed transactions with two-phase commit, as well as eventually consistent workflows with Sagas. We design and implement our programming model on Apache Flink StateFun to leverage Flink‚Äôs exactly-once processing and state management guarantees. Our experiments show that the approach of building transactional systems on top of dataflow graphs can achieve very high throughput, but with latency overhead due to checkpointing mechanism guaranteeing the exactly-once processing. We compare our approach to Beldi that implements two-phase commit on AWS lambda functions backed by DynamoDB for state management, as well as an implementation of a system that makes use of CockroachDB as its backend.}
}

@article{zorgdrager2021stateful,
  title={Stateful Entities: Object-oriented Cloud Applications as Distributed Dataflows},
  abbr = {arXiv},
  author={Zorgdrager, Wouter and Psarakis, Kyriakos and Fragkoulis, Marios and Visser, Eelco and Katsifodimos, Asterios},
  pdf = {https://arxiv.org/pdf/2112.00710.pdf},
  journal={arXiv preprint arXiv:2112.00710},
  year={2021}
}
